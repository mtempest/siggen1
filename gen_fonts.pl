#!/usr/bin/perl
use strict;
use warnings;

sub usage
{
  my $msg = shift || '';
  print <<"END";
gen_fonts.pl - create a fonts file for use with the LCD5110_Graph library
Usage: perl gen_fonts.pl config.txt output.c

$msg
END
  exit(1);
}

my $cfg_fn = $ARGV[0];
my $out_fn = $ARGV[1];
$cfg_fn or usage('No config file specified');
$out_fn or usage('No output file specified');

my $header_fn = $out_fn;
$header_fn =~ s/\.c$/.h/;

open my $cfh, "<", $cfg_fn or usage("Cannot open config file '$cfg_fn': $!");

my $text = <<"END";
// Generated by gen_fonts.pl
// Config file: $cfg_fn

#include "$header_fn"

END

my @font_names;
while (<$cfh>)
{
  # Remove trailing newline
  # remove comments
  # skip blank lines
  chomp;
  s/#.*//;
  next unless $_;

  s/^(\w+)\s+// or die "Could not extract command from '$_'";
  my $command = lc($1);
  if ($command eq 'copy')
  {
    my ($filename, $fontname) = split /[ ,]+/, $_;
    push @font_names, $fontname;
    $text .= copy_font($filename, $fontname);
    $text .= "\n";
  }
  elsif ($command eq 'pgm')
  {
    my ($filename, $fontname, $width, $height, $first, $num) = split /[ ,]+/, $_;
    push @font_names, $fontname;
    $text .= font_from_pgm($filename, $fontname, $width, $height, $first, $num);
    $text .= "\n";
  }
  else
  {
    die "Unknown command '$command'";
  }
}
$text .= "\n";

open my $ofh, ">", $out_fn or usage("Cannot create output file '$out_fn': $!");
print $ofh $text;
close $ofh;

open my $hofh, ">", $header_fn or usage("Cannot create header file '$header_fn': $!");
print $hofh <<"END";
// Generated by gen_fonts.pl
// config file: $cfg_fn

#if defined(__AVR__)
	#include <avr/pgmspace.h>
	#define fontdatatype const uint8_t
#elif defined(__PIC32MX__)
	#define PROGMEM
	#define fontdatatype const unsigned char
#elif defined(__arm__)
	#define PROGMEM
	#define fontdatatype const unsigned char
#endif

#ifdef __cplusplus
extern "C" {
#endif

END

for my $name (@font_names)
{
  print $hofh "extern fontdatatype $name [] PROGMEM;\n";
}

print $hofh <<"END";
#ifdef __cplusplus
}
#endif
END
close($hofh);
exit(0);

sub copy_font
{
  my $filename = shift;
  my $fontname = shift;

  my $text = "// from $filename\n";

  open my $ifh, "<", $filename or die "Cannot read source file '$filename': $!\n";

  while (<$ifh>)
  {
    if (/^fontdatatype (\S+)\[\]/)
    {
      my $name = $1;
      last if $name eq $fontname;
    }
  }
  die "Font '$fontname' not found in $filename\n" if eof($ifh);
  $text .= "fontdatatype $fontname"."[] PROGMEM =\n";
  while (<$ifh>)
  {
    s/[\r\n]//g;
    $text .= $_."\n";
    last if /^}/;
  }

  return $text;
}

sub font_from_pgm
{
  my $filename = shift;
  my $fontname = shift;
  my $width = shift;
  my $height = shift;
  my $first = shift;
  my $numchars = shift;

  my $text = '';

  $text .= "// from $filename\n";
  $text .= "fontdatatype $fontname"."[] PROGMEM =\n{\n";
  $text .= "$width, $height, $first, $numchars,\n";

  open my $ifh, "<", $filename or die "Cannot open pgm '$filename': $!";
  my @n;
  while (<$ifh>)
  {
    # strip trailing newline
    # remove characters
    # skip blank lines
    chomp;
    s/#.*//;
    next unless length($_);
    my @values = split /\s+/, $_;
    push @n, @values;
  }

  my $filetype = shift @n;
  $filetype eq "P2" or die "$filename has unrecognised file format\n";

  # read the image into a 2D array: 0,0 is the top-left pixel
  my $image_width = shift @n;
  my $image_height = shift @n;
  my @pixel;
  while (@n)
  {
    push @pixel, [];
    for (my $x = 0; $x < $image_width; $x++)
    {
      my $greylevel = shift @n;
      push @{$pixel[-1]}, !$greylevel;
    }
  }

  my $rows = int(($height+7)/8);
  my $characters_per_image_row = int($image_width / $width);
  for (my $i = 0; $i < $numchars; $i++)
  {
    my $c = chr($first + $i);
    $c = "sp" if $c eq ' ';

    my $start_y = int($i / $characters_per_image_row) * $height;
    my $start_x = ($i % $characters_per_image_row) * $width;
    for (my $row = 0; $row < $rows; $row++)
    {
      for (my $x = 0; $x < $width; $x++)
      {
        my $byte = 0;
        for (my $b = 0; $b < 8; $b++)
        {
          my $y = $row*8 + $b;
          if ($y < $height)
          {
            $byte |= (1<<$b) if $pixel[$start_y+$y][$start_x+$x];
          }
        }
        $text .= sprintf("0x%02x, ", $byte);
      }
    }
    $text .= " // $c\n";
  }

  $text .= "};\n";

  # Remove the comma after the last value
  $text =~ s/,( +\/\/ .\n})/ $1/;

  return $text;
}
